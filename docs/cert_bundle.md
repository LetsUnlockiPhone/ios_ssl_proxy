### Documentation on the iOS 9 certificate bundle stored at /System/Library/Security/Certificates.bundle


### Here is the code to parse the index and the table in PSCertData.m under https://opensource.apple.com/source/Security/Security-57031.1.35/certificates/CertificateTool/CertificateTool/

Files in the directory /System/Library/Security/Certificates.bundle:

Allowed.plist
AppleESCertificates.plist
AssetVersion.plist
Blocked.plist
certsIndex.data
certsTable.data
EVRoots.plist
GrayListedKeys.plist
Info.plist
manifest.data
TrustedCTLogs.plist
TrustStore.html


# Hashes found from cerrtsIndex.data in certsTable.data:

found hash a888eb1220701cd1d849d3d8b33a5ac4d98cb449 with pos=194553 len=52
found hash a888eb1220701cd1d849d3d8b33a5ac4d98cb449 with pos=194639 len=52
found hash a888eb1220701cd1d849d3d8b33a5ac4d98cb449 with pos=195078 len=52
found hash 16ed8643c493898f804c5ed9596c80128348f0b3 with pos=115193 len=55		O = TeliaSonera, CN = TeliaSonera Root CA v1
found hash 16ed8643c493898f804c5ed9596c80128348f0b3 with pos=115282 len=55		O = TeliaSonera, CN = TeliaSonera Root CA v1
found hash ce7bb519fd2c57b5b56c2ac49174f60a208cd04e with pos=55 len=56			C = ES, O = IZENPE S.A., CN = Izenpe.com
found hash ce7bb519fd2c57b5b56c2ac49174f60a208cd04e with pos=145 len=56			C = ES, O = IZENPE S.A., CN = Izenpe.com
found hash ce7bb519fd2c57b5b56c2ac49174f60a208cd04e with pos=1592 len=56		C = ES, O = IZENPE S.A., CN = Izenpe.com
found hash ce7bb519fd2c57b5b56c2ac49174f60a208cd04e with pos=1682 len=56		C = ES, O = IZENPE S.A., CN = Izenpe.com
found hash 136f24a2c8b41164e8e5b1b9e9a4f52d0e2afde0 with pos=73049 len=63		C = TW, O = Government Root Certification Authority
found hash 136f24a2c8b41164e8e5b1b9e9a4f52d0e2afde0 with pos=73146 len=63		C = TW, O = Government Root Certification Authority
found hash 3a2bc436e153c993237a6e7b7f1b1c717831dfce with pos=110816 len=65
found hash 3a2bc436e153c993237a6e7b7f1b1c717831dfce with pos=110915 len=65
found hash a0f7e4cb6e7b51b5597be6c42aafbfb100a02ff6 with pos=98464 len=68
found hash a0f7e4cb6e7b51b5597be6c42aafbfb100a02ff6 with pos=98566 len=68
found hash 0734991dbb569ce212834d9e7d1c4dc07c3fed33 with pos=127296 len=68
found hash 0734991dbb569ce212834d9e7d1c4dc07c3fed33 with pos=127398 len=68
found hash 90798777573773b9f45f05b3ce2019618c707825 with pos=6949 len=69
found hash 90798777573773b9f45f05b3ce2019618c707825 with pos=7052 len=69
found hash 4c94e14a51b67b8329922ea7f6ea4cf780b8b0b0 with pos=37873 len=75
found hash 4c94e14a51b67b8329922ea7f6ea4cf780b8b0b0 with pos=37982 len=75
found hash 56e67b0346cc983138dd97c3476541bd154e11e7 with pos=195497 len=75
found hash 56e67b0346cc983138dd97c3476541bd154e11e7 with pos=195606 len=75
found hash 374fe13049fe5fdb840a5ce98778547c4aeb40a0 with pos=154035 len=77
found hash 374fe13049fe5fdb840a5ce98778547c4aeb40a0 with pos=154146 len=77
found hash 9de6a2d73b66a69a207b585dc47ca40e93047c70 with pos=60089 len=78
found hash 9de6a2d73b66a69a207b585dc47ca40e93047c70 with pos=60201 len=78
found hash 536caab1d9bded8bbc749a482e70d69fa51d45ee with pos=74401 len=78
found hash 536caab1d9bded8bbc749a482e70d69fa51d45ee with pos=74513 len=78
found hash 83e18176434a71e3a00d2afa608d117a8d9cd783 with pos=56509 len=80
found hash 83e18176434a71e3a00d2afa608d117a8d9cd783 with pos=56623 len=80
found hash dab7e8c94f3f0a9f1a04d7279d0231dd4d3f0e4b with pos=129291 len=80
found hash dab7e8c94f3f0a9f1a04d7279d0231dd4d3f0e4b with pos=129405 len=80
found hash fae3a76047b56651ced60a4780480f38246512c0 with pos=30248 len=81
found hash fae3a76047b56651ced60a4780480f38246512c0 with pos=30363 len=81
found hash d3af94dd41d2ac737c32c7dbe7651bc45a52b006 with pos=89484 len=88
found hash d3af94dd41d2ac737c32c7dbe7651bc45a52b006 with pos=89606 len=88
found hash 3347452ab1b6d6d4468600dae01ee33e4617d280 with pos=13428 len=90
found hash 3347452ab1b6d6d4468600dae01ee33e4617d280 with pos=13552 len=90
found hash 2789aeec302ebbe633999585f625668a04d56f85 with pos=138324 len=90
found hash 2789aeec302ebbe633999585f625668a04d56f85 with pos=138448 len=90
found hash b84737cd38323c6d353c2f54d27908a1cacd94d3 with pos=198368 len=94
found hash b84737cd38323c6d353c2f54d27908a1cacd94d3 with pos=198496 len=94
found hash 5e211447e2b673b3c8ee9f3f3725085e10459577 with pos=205353 len=95
found hash 5e211447e2b673b3c8ee9f3f3725085e10459577 with pos=205482 len=95
found hash 5b5db9a8fe00e82f317b0aa9acf56f6b7cab0b71 with pos=17097 len=100
found hash 5b5db9a8fe00e82f317b0aa9acf56f6b7cab0b71 with pos=17231 len=100
found hash 41a73072f14fb59ff67fa5c84804cf3b7b34ac63 with pos=86312 len=103
found hash 41a73072f14fb59ff67fa5c84804cf3b7b34ac63 with pos=86449 len=103
found hash 549bc53496968e371ad1d3914c71e733ba7721cf with pos=152205 len=103
found hash 549bc53496968e371ad1d3914c71e733ba7721cf with pos=152342 len=103
found hash e4971d84b9fd6eccf1fb3f757c35d0f2183665ce with pos=96984 len=107
found hash e4971d84b9fd6eccf1fb3f757c35d0f2183665ce with pos=97125 len=107
found hash 8304ff77b4809b2917db62a59a296b01289fa82f with pos=25416 len=117
found hash 8304ff77b4809b2917db62a59a296b01289fa82f with pos=25571 len=117
found hash eead83e6edb095758eff8af2aaf637ce2f5eef40 with pos=100545 len=123
found hash eead83e6edb095758eff8af2aaf637ce2f5eef40 with pos=100702 len=123
found hash ff51c0f5977bbba38c22858df613c081075b1f03 with pos=158241 len=126
found hash ff51c0f5977bbba38c22858df613c081075b1f03 with pos=158401 len=126
found hash f39d0c41716ed61230b439c378acd65ed009beb5 with pos=210665 len=127
found hash f39d0c41716ed61230b439c378acd65ed009beb5 with pos=210826 len=127
found hash cfd4e05658b53b55e65cdc5c7c0768136b2c62fa with pos=50809 len=128
found hash cfd4e05658b53b55e65cdc5c7c0768136b2c62fa with pos=50972 len=128
found hash cc79502406a98af43daa28689362b990b88285cd with pos=107738 len=130
found hash cc79502406a98af43daa28689362b990b88285cd with pos=107903 len=130
found hash 49399167d8cdb3d3ce3b8a3b6c64181c4fb6f808 with pos=117930 len=130
found hash 49399167d8cdb3d3ce3b8a3b6c64181c4fb6f808 with pos=118095 len=130
found hash 1caa26fadda95025a46badaf1b4c656f0a41443c with pos=180402 len=130
found hash 1caa26fadda95025a46badaf1b4c656f0a41443c with pos=180567 len=130
found hash 391f460ede149158e34f0881c3ea9f11fd6b7ff6 with pos=137090 len=133
found hash 391f460ede149158e34f0881c3ea9f11fd6b7ff6 with pos=137258 len=133
found hash 391f460ede149158e34f0881c3ea9f11fd6b7ff6 with pos=137861 len=133
found hash 69a71a02ac6d483b918358483e60fc4be5deb88a with pos=43076 len=139
found hash 69a71a02ac6d483b918358483e60fc4be5deb88a with pos=43250 len=139
found hash 1f20d9b038d2c5e7c40c4386c8f3761aae564f4e with pos=166660 len=141
found hash 1f20d9b038d2c5e7c40c4386c8f3761aae564f4e with pos=166836 len=141
found hash 5045b7385e3b00d9334968faa47a8ad21921d267 with pos=157183 len=167
found hash 5045b7385e3b00d9334968faa47a8ad21921d267 with pos=157385 len=167
found hash f03abb98e293711dfb4d8fd2e32e7294fe91425d with pos=91841 len=178
found hash f03abb98e293711dfb4d8fd2e32e7294fe91425d with pos=92054 len=178
found hash c7233045bc954f6f311a6cb17dff91530fa16416 with pos=123418 len=183
found hash c7233045bc954f6f311a6cb17dff91530fa16416 with pos=123636 len=183
found hash 2a935a150cec8661e98bf30ac715c90827243fc4 with pos=167653 len=183
found hash 2a935a150cec8661e98bf30ac715c90827243fc4 with pos=167871 len=183
found hash b703986b44026a324a8d3f41af0f6a2fa66910ae with pos=57386 len=190
found hash b703986b44026a324a8d3f41af0f6a2fa66910ae with pos=57611 len=190
found hash 2eb089564c2f4d59f8b5f06a0749d9fed0ad345f with pos=52330 len=191
found hash 2eb089564c2f4d59f8b5f06a0749d9fed0ad345f with pos=52556 len=191
found hash 215bf2eebec904d49d6072a3894a3ea5948a3688 with pos=61480 len=266		C = ES, ST = Barcelona, L = Barcelona (see current address at http://www.anf.es/es/address-direccion.html ), O = ANF Autoridad de Certificacion, OU = ANF Clase 1 CA, emailAddress = info@anf.es, serialNumber = G63287510, CN = ANF Global Root CA
found hash 215bf2eebec904d49d6072a3894a3ea5948a3688 with pos=61782 len=266		C = ES, ST = Barcelona, L = Barcelona (see current address at http://www.anf.es/es/address-direccion.html ), O = ANF Autoridad de Certificacion, OU = ANF Clase 1 CA, emailAddress = info@anf.es, serialNumber = G63287510, CN = ANF Global Root CA
found hash fc43f2c518e5b0175f254eb9a99c744316047876 with pos=5027 len=299		C = TR, L = Gebze - Kocaeli, O = T\C3\BCrkiye Bilimsel ve Teknolojik Ara\C5\9Ft\C4\B1rma Kurumu - T\C3\9CB\C4\B0TAK, OU = Ulusal Elektronik ve Kriptoloji Ara\C5\9Ft\C4\B1rma Enstit\C3\BCs\C3\BC - UEKAE, OU = Kamu Sertifikasyon Merkezi, CN = T\C3\9CB\C4\B0TAK UEKAE K\C3\B6k Sertifika Hizmet Sa\C4\9Flay\C4\B1c\C4\B1s\C4\B1 - S\C3\BCr\C3\BCm 3
found hash fc43f2c518e5b0175f254eb9a99c744316047876 with pos=5362 len=299		C = TR, L = Gebze - Kocaeli, O = T\C3\BCrkiye Bilimsel ve Teknolojik Ara\C5\9Ft\C4\B1rma Kurumu - T\C3\9CB\C4\B0TAK, OU = Ulusal Elektronik ve Kriptoloji Ara\C5\9Ft\C4\B1rma Enstit\C3\BCs\C3\BC - UEKAE, OU = Kamu Sertifikasyon Merkezi, CN = T\C3\9CB\C4\B0TAK UEKAE K\C3\B6k Sertifika Hizmet Sa\C4\9Flay\C4\B1c\C4\B1s\C4\B1 - S\C3\BCr\C3\BCm 3


### From https://opensource.apple.com/source/Security/Security-57740.1.18/OTAPKIAssetTool/OTAServiceApp.m.auto.html:

### The certificate bundle is also here: https://opensource.apple.com/source/Security/Security-57031.1.35/certificates/CertificateTool/Asset/SecurityCertificatesAssets/AssetData/PKITrustData/

<string>/usr/libexec/OTAPKIAssetTool</string>

	<key>com.apple.private.assets.accessible-asset-types</key>
	<array>
		<string>com.apple.MobileAsset.PKITrustServices.PKITrustData</string>
	</array>

	kBaseAssetDirectoryPath -	This is the full path on the device that 
								will contain the Assets directory.  This
								directory was chosen because it is owned
								by securityd
								
	kkManifestFileName - 		The file name of the manifest file for the
								OTA PKI trust asset

	kCertsIndexFileName - 		The file name of the asset file that contains
								a hash table of offsets into the cert table
								file.  This is used to look up anchor certs.
								
	kCertsTableFileName - 		The file name of the asset file that contains
								all of the anchor certificates.  The 
								kCertsIndexFileName file is used to find the 
								correct offset in this file to retrieve a
								specific anchor certificate.

static const NSString* kManifestFileName = @"manifest.data";
static const NSString* kAllowListFileName = @"Allowed.plist";
static const NSString* kAssetVersionFileName =  @"AssetVersion.plist";
static const NSString* kAppleESCertificatesName = @"AppleESCertificates.plist";
static const NSString* kBlockKeyFileName = @"Blocked.plist";
static const NSString* kGrayListedKeysFileName = @"GrayListedKeys.plist";
static const NSString* kEVRootsFileName = @"EVRoots.plist";
static const NSString* kCTLogsFileName = @"TrustedCTLogs.plist";
static const NSString* kCertsIndexFileName = @"certsIndex.data";
static const NSString* kCertsTableFileName = @"certsTable.data";


            _normalized_subject_hash = [self getNormalizedSubjectHash:certRef];
            if (NULL == _normalized_subject_hash)
            {
                NSLog(@"PSCert: Unable to get the normalized subject hash for file %@", filePath);
                return nil;
            }

        // Get the hash
        NSData* normalized_subject_hash = aCert.normalized_subject_hash;
        if (nil == normalized_subject_hash)
        {
            NSLog(@"Could not get the normalized hash for the cert at %@", aCert.file_path);
            continue;
        }

// X.501	ISO/IEC 9594-2	The Directory: Models
// X.509	ISO/IEC 9594-8	The Directory: Public-key and attribute certificate frameworks
// Apple uses libDER: https://opensource.apple.com/source/CommonCrypto/CommonCrypto-60027/Source/libDER/libDER/

/* Given the contents of an X.501 Name return the contents of a normalized
   X.501 name. */
CFDataRef createNormalizedX501Name(CFAllocatorRef allocator,
	const DERItem *x501name) {
    CFMutableDataRef result = CFDataCreateMutable(allocator, x501name->length);
    CFIndex length = x501name->length;
    CFDataSetLength(result, length);
    UInt8 *base = CFDataGetMutableBytePtr(result);

	DERSequence rdnSeq;
	DERReturn drtn = DERDecodeSeqContentInit(x501name, &rdnSeq);

	require_noerr_quiet(drtn, badDER);
	DERDecodedInfo rdn;

    /* Always points to last rdn tag. */
    const DERByte *rdnTag = rdnSeq.nextItem;
    /* Offset relative to base of current rdn set tag. */
    CFIndex rdnTagLocation = 0;
	while ((drtn = DERDecodeSeqNext(&rdnSeq, &rdn)) == DR_Success) {
		require_quiet(rdn.tag == ASN1_CONSTR_SET, badDER);
		/* We don't allow empty RDNs. */
		require_quiet(rdn.content.length != 0, badDER);
        /* Length of the tag and length of the current rdn. */
        CFIndex rdnTLLength = rdn.content.data - rdnTag;
        CFIndex rdnContentLength = rdn.content.length;
        /* Copy the tag and length of the RDN. */
        memcpy(base + rdnTagLocation, rdnTag, rdnTLLength);

		DERSequence atvSeq;
		drtn = DERDecodeSeqContentInit(&rdn.content, &atvSeq);
        DERDecodedInfo atv;
        /* Always points to tag of current atv sequence. */
        const DERByte *atvTag = atvSeq.nextItem;
        /* Offset relative to base of current atv sequence tag. */
        CFIndex atvTagLocation = rdnTagLocation + rdnTLLength;
		while ((drtn = DERDecodeSeqNext(&atvSeq, &atv)) == DR_Success) {
			require_quiet(atv.tag == ASN1_CONSTR_SEQUENCE, badDER);
            /* Length of the tag and length of the current atv. */
            CFIndex atvTLLength = atv.content.data - atvTag;
            CFIndex atvContentLength = atv.content.length;
            /* Copy the tag and length of the atv and the atv itself. */
            memcpy(base + atvTagLocation, atvTag,
                atvTLLength + atv.content.length);

            /* Now decode the atv sequence. */
			DERAttributeTypeAndValue atvPair;
			drtn = DERParseSequenceContent(&atv.content,
				DERNumAttributeTypeAndValueItemSpecs,
				DERAttributeTypeAndValueItemSpecs,
				&atvPair, sizeof(atvPair));
			require_noerr_quiet(drtn, badDER);
			require_quiet(atvPair.type.length != 0, badDER);
            DERDecodedInfo value;
            drtn = DERDecodeItem(&atvPair.value, &value);
			require_noerr_quiet(drtn, badDER);

            /* (c) attribute values in PrintableString are not case sensitive
               (e.g., "Marianne Swanson" is the same as "MARIANNE SWANSON"); and

               (d) attribute values in PrintableString are compared after
               removing leading and trailing white space and converting internal
               substrings of one or more consecutive white space characters to a
               single space. */
            if (value.tag == ASN1_PRINTABLE_STRING) {
                /* Offset relative to base of current value tag. */
                CFIndex valueTagLocation = atvTagLocation + atvPair.value.data - atvTag;
                CFIndex valueTLLength = value.content.data - atvPair.value.data;
                CFIndex valueContentLength = value.content.length;

                /* Now copy all the bytes, but convert to upper case while
                   doing so and convert multiple whitespace chars into a
                   single space. */
                bool lastWasBlank = false;
                CFIndex valueLocation = valueTagLocation + valueTLLength;
                CFIndex valueCurrentLocation = valueLocation;
                CFIndex ix;
                for (ix = 0; ix < valueContentLength; ++ix) {
                    UInt8 ch = value.content.data[ix];
                    if (isblank(ch)) {
                        if (lastWasBlank) {
                            continue;
                        } else {
                            /* Don't insert a space for first character
                               we encounter. */
                            if (valueCurrentLocation > valueLocation) {
                                base[valueCurrentLocation++] = ' ';
                            }
                            lastWasBlank = true;
                        }
                    } else {
                        lastWasBlank = false;
                        if ('a' <= ch && ch <= 'z') {
                            base[valueCurrentLocation++] = ch + 'A' - 'a';
                        } else {
                            base[valueCurrentLocation++] = ch;
                        }
                    }
                }
                /* Finally if lastWasBlank remove the trailing space. */
                if (lastWasBlank && valueCurrentLocation > valueLocation) {
                    valueCurrentLocation--;
                }
                /* Adjust content length to normalized length. */
                valueContentLength = valueCurrentLocation - valueLocation;

                /* Number of bytes by which the length should be shorted. */
                CFIndex lengthDiff = value.content.length - valueContentLength;
                if (lengthDiff == 0) {
                    /* Easy case no need to adjust lengths. */
                } else {
                    /* Hard work we need to go back and fix up length fields
                       for:
                           1) The value itself.
                           2) The ATV Sequence containing type/value
                           3) The RDN Set containing one or more atv pairs.
                           4) The result.
                       */

                    /* Step 1 fix up length of value. */
                    /* Length of value tag and length minus the tag. */
                    DERSize newValueTLLength = valueTLLength - 1;
                    drtn = DEREncodeLength(valueContentLength,
                        base + valueTagLocation + 1, &newValueTLLength);
                    /* Add the length of the tag back in. */
                    newValueTLLength++;
                    CFIndex valueLLDiff = valueTLLength - newValueTLLength;
                    if (valueLLDiff) {
                        /* The size of the length field changed, let's slide
                           the value back by valueLLDiff bytes. */
                        memmove(base + valueTagLocation + newValueTLLength,
                            base + valueTagLocation + valueTLLength,
                            valueContentLength);
                        /* The length diff for the enclosing object. */
                        lengthDiff += valueLLDiff;
                    }

                    /* Step 2 fix up length of the enclosing ATV Sequence. */
                    atvContentLength -= lengthDiff;
                    DERSize newATVTLLength = atvTLLength - 1;
                    drtn = DEREncodeLength(atvContentLength,
                        base + atvTagLocation + 1, &newATVTLLength);
                    /* Add the length of the tag back in. */
                    newATVTLLength++;
                    CFIndex atvLLDiff = atvTLLength - newATVTLLength;
                    if (atvLLDiff) {
                        /* The size of the length field changed, let's slide
                           the value back by valueLLDiff bytes. */
                        memmove(base + atvTagLocation + newATVTLLength,
                            base + atvTagLocation + atvTLLength,
                            atvContentLength);
                        /* The length diff for the enclosing object. */
                        lengthDiff += atvLLDiff;
                        atvTLLength = newATVTLLength;
                    }

                    /* Step 3 fix up length of enclosing RDN Set. */
                    rdnContentLength -= lengthDiff;
                    DERSize newRDNTLLength = rdnTLLength - 1;
                    drtn = DEREncodeLength(rdnContentLength,
                        base + rdnTagLocation + 1, &newRDNTLLength);
                    /* Add the length of the tag back in. */
                    newRDNTLLength++;
                    CFIndex rdnLLDiff = rdnTLLength - newRDNTLLength;
                    if (rdnLLDiff) {
                        /* The size of the length field changed, let's slide
                           the value back by valueLLDiff bytes. */
                        memmove(base + rdnTagLocation + newRDNTLLength,
                            base + rdnTagLocation + rdnTLLength,
                            rdnContentLength);
                        /* The length diff for the enclosing object. */
                        lengthDiff += rdnLLDiff;
                        rdnTLLength = newRDNTLLength;

                        /* Adjust the locations that might have changed due to
                           this slide. */
                        atvTagLocation -= rdnLLDiff;
                    }
                }
            }
            atvTagLocation += atvTLLength + atvContentLength;
            atvTag = atvSeq.nextItem;
		}
        rdnTagLocation += rdnTLLength + rdnContentLength;
        rdnTag = rdnSeq.nextItem;
	}
	require_quiet(drtn == DR_EndOfSequence, badDER);
    /* Truncate the result to the proper length. */
    CFDataSetLength(result, rdnTagLocation);

	return result;

badDER:
    CFRelease(result);
    return NULL;
}

// from https://opensource.apple.com/source/Security/Security-55471/sec/Security/SecCertificate.c
static bool SecCertificateParse(SecCertificateRef certificate)
{
....
    certificate->_normalizedIssuer = createNormalizedX501Name(allocator,
        &tbsCert.issuer);
....
    certificate->_normalizedSubject = createNormalizedX501Name(allocator,
        &tbsCert.subject);
....
}

CFDataRef SecCertificateGetNormalizedIssuerContent(
    SecCertificateRef certificate) {
    return certificate->_normalizedIssuer;
}

static CFDataRef GetNormalizedIssuerContent(SecCertificateRefP cert)
{
    struct __SecCertificateP *certP = (struct __SecCertificateP *)cert;
    if (!certP) {
        return NULL;
    }
    return certP->_normalizedIssuer;
}

// This is from the SecCertificateInternal.h file
// https://opensource.apple.com/source/Security/Security-55471/sec/Security/SecCertificateInternal.h.auto.html
//CFDataRef SecCertificateGetNormalizedIssuerContentP(SecCertificateRefP certificate);
//CFDataRef SecCertificateGetNormalizedSubjectContentP(SecCertificateRefP certificate);

- (NSData *)getNormalizedSubjectHash:(SecCertificateRef)cert_ref
{
    NSData* result = nil;

    if (NULL == cert_ref)
    {
        return result;
    }
    SecCertificateRefP iosCertRef = NULL;
    NSData* normalized_subject = NULL;
    CFDataRef cert_data = SecCertificateCopyData(cert_ref);
    if (NULL == cert_data)
    {
        NSLog(@"SecCertificateCopyData returned NULL");
        return result;
    }

    iosCertRef = SecCertificateCreateWithDataP(NULL, cert_data);
    CFRelease(cert_data);

    if (NULL != iosCertRef)
    {
        CFDataRef temp_data = GetNormalizedIssuerContent(iosCertRef);

        if (NULL == temp_data)
        {
            CFStringRef name = SecCertificateCopySubjectSummary(cert_ref);
            NSLog(@"SecCertificateGetNormalizedIssuerContent returned NULL for %@", name);
            if (name)
                CFRelease(name);
            CFRelease(iosCertRef);
            return result;
        }
        normalized_subject = [NSData dataWithBytes:CFDataGetBytePtr(temp_data) length:CFDataGetLength(temp_data)];
        CFRelease(iosCertRef);
    }

    if (NULL == normalized_subject)
    {

        NSLog(@"SecCertificateGetNormalizedIssuerContent returned NULL");
        return result;
    }

    unsigned char subject_digest[CCSHA1_OUTPUT_SIZE];
    memset(subject_digest, 0, CCSHA1_OUTPUT_SIZE);
    const struct ccdigest_info* digest_info = ccsha1_di();

    ccdigest(digest_info, (unsigned long)[normalized_subject length], [normalized_subject bytes], subject_digest);

    result = [NSData dataWithBytes:subject_digest length:CCSHA1_OUTPUT_SIZE];

    return result;
}


### manifest.data
binary plist containing hashes of all other files in this directory

### certsTable.data
Contains actual CA certificates in DER format

### certIndex.data
Seems to be a list of SHA1 hashes of the CA certs in certsTable.data separated by \x00\x00.

### Allowed.plist
Binary plist containing list of allowed certificates. The two main groups of which each is a subgroup are:
1) 65F231AD2AF7F7DD52960AC702C10EEFA6D53B11
2) 7C724B39C7C0DB62A54F9BAA183492A2CA838259

The format of this file is the following:

        <key>65F231AD2AF7F7DD52960AC702C10EEFA6D53B11</key>
        <array>
                <data>
                AFv5ju1hK1Ds2nv/VqLf9GeordfuwKswV1TXZr67X+g=	(005BF98EED612B50ECDA7BFF56A2DFF467A8ADD7EEC0AB305754D766BEBB5FE8)
                </data>
                <data>
                AId1uOrQ/hYmnJqasoM5VUnKZ8KjqugvGmtNOrzK3Cc=	(008775B8EAD0FE16269C9A9AB283395549CA67C2A3AAE82F1A6B4D3ABCCADC27)
                </data>
...


The length of each entry is 32 bytes long, so probably SHA256.
